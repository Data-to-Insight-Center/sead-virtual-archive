package org.seadva.registry.database.services.data;

import java.io.Serializable;

import org.hibernate.connection.ConnectionProvider;
import org.hibernate.context.ManagedSessionContext;
import org.hibernate.impl.SessionFactoryImpl;
import org.seadva.registry.database.factories.vaRegistry.*;
import org.seadva.registry.database.model.obj.vaRegistry.Agent;
import org.seadva.registry.database.model.obj.vaRegistry.AgentProfile;
import org.seadva.registry.database.model.obj.vaRegistry.AgentProfilePK;
import org.seadva.registry.database.model.obj.vaRegistry.AgentRole;
import org.seadva.registry.database.model.obj.vaRegistry.AgentRolePK;
import org.seadva.registry.database.model.obj.vaRegistry.Aggregation;
import org.seadva.registry.database.model.obj.vaRegistry.AggregationPK;
import org.seadva.registry.database.model.obj.vaRegistry.BaseEntity;
import org.seadva.registry.database.model.obj.vaRegistry.Collection;
import org.seadva.registry.database.model.obj.vaRegistry.DataIdentifier;
import org.seadva.registry.database.model.obj.vaRegistry.DataIdentifierPK;
import org.seadva.registry.database.model.obj.vaRegistry.DataIdentifierType;
import org.seadva.registry.database.model.obj.vaRegistry.DataLocation;
import org.seadva.registry.database.model.obj.vaRegistry.DataLocationPK;
import org.seadva.registry.database.model.obj.vaRegistry.EntityContent;
import org.seadva.registry.database.model.obj.vaRegistry.EntityType;
import org.seadva.registry.database.model.obj.vaRegistry.EntityTypePK;
import org.seadva.registry.database.model.obj.vaRegistry.Event;
import org.seadva.registry.database.model.obj.vaRegistry.EventType;
import org.seadva.registry.database.model.obj.vaRegistry.File;
import org.seadva.registry.database.model.obj.vaRegistry.Fixity;
import org.seadva.registry.database.model.obj.vaRegistry.FixityPK;
import org.seadva.registry.database.model.obj.vaRegistry.Format;
import org.seadva.registry.database.model.obj.vaRegistry.MetadataReference;
import org.seadva.registry.database.model.obj.vaRegistry.MetadataType;
import org.seadva.registry.database.model.obj.vaRegistry.ProfileType;
import org.seadva.registry.database.model.obj.vaRegistry.Property;
import org.seadva.registry.database.model.obj.vaRegistry.Relation;
import org.seadva.registry.database.model.obj.vaRegistry.RelationPK;
import org.seadva.registry.database.model.obj.vaRegistry.RelationType;
import org.seadva.registry.database.model.obj.vaRegistry.Repository;
import org.seadva.registry.database.model.obj.vaRegistry.RoleType;
import org.seadva.registry.database.model.obj.vaRegistry.State;
import org.seadva.registry.database.model.obj.vaRegistry.Transition;
import org.seadva.registry.database.model.obj.vaRegistry.TransitionPK;
import org.hibernate.Criteria;
import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.ReplicationMode;
import org.hibernate.Session;
import com.felees.hbnpojogen.persistence.IPojoGenEntity;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;
import com.felees.hbnpojogen.persistence.GenericDAO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.hibernate.LockMode;
import org.hibernate.SessionFactory;
import org.hibernate.proxy.HibernateProxy;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.transaction.TransactionConfiguration;
import org.springframework.transaction.annotation.Transactional;

import javax.persistence.Basic;
import javax.persistence.FetchType;

/**
 * Data layer.
 * @author autogenerated
 */
@org.springframework.stereotype.Component
public class DataLayerVaRegistryImpl implements DataLayerVaRegistry {
	/** Singleton reference to this class. */
	private static DataLayerVaRegistry instance;
	/** map lock. */
	private static Object daoMapLock = new Object();

	/** Internal handle. */
	private static Map<Class<?>, GenericDAO<?, ?>> daoMap = null; 
	
		/** Inner handle. */
	private static ApplicationContext context;
 /** Sessionfactory in use. Filled in by Spring. */ 
    private SessionFactory sessionFactory = null;
	
	/** Handle to get back ourselves and perform correct injection. 
	 * @param ctxt filled by spring
	 */
	@Autowired
	public void setApplicationContext(ApplicationContext ctxt) {
		DataLayerVaRegistryImpl.context = ctxt;
	}
	
	
		
 	/**
     * Set session factory.
     * @param sessionFactory sessionfactory to use. 
     */
    @Autowired
    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }
    
    /** 
	* Returns a DAO instance of the given type.
	* @param <T> Type
	* @param persistentObject to get
	* @return GenericDAO<T, ?> object
     */
    @SuppressWarnings("unchecked")
    private <T> GenericDAO<T, ?> getDAO(final T persistentObject) {
		T persistent = persistentObject;

		synchronized (daoMapLock) {
    		if (daoMap == null) {
    			daoMap = new ConcurrentHashMap<Class<?>, GenericDAO<?, ?>>(); 
	 	   		daoMap.put(Agent.class, HibernateVaRegistryDaoFactory.getAgentDao());
	 	   		daoMap.put(AgentProfile.class, HibernateVaRegistryDaoFactory.getAgentProfileDao());
	 	   		daoMap.put(AgentRole.class, HibernateVaRegistryDaoFactory.getAgentRoleDao());
	 	   		daoMap.put(Aggregation.class, HibernateVaRegistryDaoFactory.getAggregationDao());
	 	   		daoMap.put(BaseEntity.class, HibernateVaRegistryDaoFactory.getBaseEntityDao());
	 	   		daoMap.put(Collection.class, HibernateVaRegistryDaoFactory.getCollectionDao());
	 	   		daoMap.put(DataIdentifier.class, HibernateVaRegistryDaoFactory.getDataIdentifierDao());
	 	   		daoMap.put(DataIdentifierType.class, HibernateVaRegistryDaoFactory.getDataIdentifierTypeDao());
	 	   		daoMap.put(DataLocation.class, HibernateVaRegistryDaoFactory.getDataLocationDao());
	 	   		daoMap.put(EntityContent.class, HibernateVaRegistryDaoFactory.getEntityContentDao());
	 	   		daoMap.put(EntityType.class, HibernateVaRegistryDaoFactory.getEntityTypeDao());
	 	   		daoMap.put(Event.class, HibernateVaRegistryDaoFactory.getEventDao());
	 	   		daoMap.put(EventType.class, HibernateVaRegistryDaoFactory.getEventTypeDao());
	 	   		daoMap.put(File.class, HibernateVaRegistryDaoFactory.getFileDao());
	 	   		daoMap.put(Fixity.class, HibernateVaRegistryDaoFactory.getFixityDao());
	 	   		daoMap.put(Format.class, HibernateVaRegistryDaoFactory.getFormatDao());
	 	   		daoMap.put(MetadataReference.class, HibernateVaRegistryDaoFactory.getMetadataReferenceDao());
	 	   		daoMap.put(MetadataType.class, HibernateVaRegistryDaoFactory.getMetadataTypeDao());
	 	   		daoMap.put(ProfileType.class, HibernateVaRegistryDaoFactory.getProfileTypeDao());
	 	   		daoMap.put(Property.class, HibernateVaRegistryDaoFactory.getPropertyDao());
	 	   		daoMap.put(Relation.class, HibernateVaRegistryDaoFactory.getRelationDao());
	 	   		daoMap.put(RelationType.class, HibernateVaRegistryDaoFactory.getRelationTypeDao());
	 	   		daoMap.put(Repository.class, HibernateVaRegistryDaoFactory.getRepositoryDao());
	 	   		daoMap.put(RoleType.class, HibernateVaRegistryDaoFactory.getRoleTypeDao());
	 	   		daoMap.put(State.class, HibernateVaRegistryDaoFactory.getStateDao());
	 	   		daoMap.put(Transition.class, HibernateVaRegistryDaoFactory.getTransitionDao());
    		}
		 }
		if (persistentObject instanceof HibernateProxy) {
			persistent = (T) ((HibernateProxy) persistentObject).getHibernateLazyInitializer().getImplementation();
		} 
		
		GenericDAO<T, ?> result = (GenericDAO<T, ?>) daoMap.get(persistent.getClass());
		if (result == null) {
			throw new IllegalAccessError("The given object is of an incorrect type. ");
		}
		return result;
    }

    /**
     * Deletes the given object from disk.
     * @param <T> A DataLayerObject-derived type
     * @param persistentObject Object to delete
     */
    public <T> void delete(T persistentObject) {
    	    	getDAO(persistentObject).delete(persistentObject);
    }
    /**
     * Refresh the object $class.className from disk.
     * @param <T> A DataLayerObject-derived type
     * @param persistentObject Object to reload
     */
    public <T> void refresh(T persistentObject) {
	    	getDAO(persistentObject).refresh(persistentObject);
    }

    /**
     * Saves the given object to disk.
     * @param persistentObject Object to save
	 * @param <T> A DataLayerObject-derived type
     * @return Identifier of saved object 
     */
    public <T> Serializable save(T persistentObject) {
        return getDAO(persistentObject).save(persistentObject);
    }
    /**
     * Saves or updates the given $class.className object to disk.
	 * @param <T> A DataLayerObject-derived type
     * @param persistentObject Object to save 
     */
    @Transactional
    public <T> void saveOrUpdate(T persistentObject) {
        getDAO(persistentObject).saveOrUpdate(persistentObject);
    }
    /**
     * Updates the given object to disk.
	 * @param <T> A DataLayerObject-derived type
     * @param persistentObject Object to update 
     */
    public <T> void update(T persistentObject) {
        getDAO(persistentObject).update(persistentObject);
    }


    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Agent obj) directly
     * @param id Identifier to delete
     */
    public void deleteAgent(final String id)  {
        HibernateVaRegistryDaoFactory.getAgentDao().delete(loadAgent(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Agent object
     */
    public Agent loadAgent(final String id) {
        return HibernateVaRegistryDaoFactory.getAgentDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
    @Transactional
     public Agent getAgent(final String id) {
        return HibernateVaRegistryDaoFactory.getAgentDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (AgentProfile obj) directly
     * @param id Identifier to delete
     */
    public void deleteAgentProfile(final AgentProfilePK id)  {
        HibernateVaRegistryDaoFactory.getAgentProfileDao().delete(loadAgentProfile(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a AgentProfile object
     */
    public AgentProfile loadAgentProfile(final AgentProfilePK id) {
        return HibernateVaRegistryDaoFactory.getAgentProfileDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public AgentProfile getAgentProfile(final AgentProfilePK id) {
        return HibernateVaRegistryDaoFactory.getAgentProfileDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (AgentRole obj) directly
     * @param id Identifier to delete
     */
    public void deleteAgentRole(final AgentRolePK id)  {
        HibernateVaRegistryDaoFactory.getAgentRoleDao().delete(loadAgentRole(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a AgentRole object
     */
    public AgentRole loadAgentRole(final AgentRolePK id) {
        return HibernateVaRegistryDaoFactory.getAgentRoleDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public AgentRole getAgentRole(final AgentRolePK id) {
        return HibernateVaRegistryDaoFactory.getAgentRoleDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Aggregation obj) directly
     * @param id Identifier to delete
     */
    public void deleteAggregation(final AggregationPK id)  {
        HibernateVaRegistryDaoFactory.getAggregationDao().delete(loadAggregation(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Aggregation object
     */
    public Aggregation loadAggregation(final AggregationPK id) {
        return HibernateVaRegistryDaoFactory.getAggregationDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Aggregation getAggregation(final AggregationPK id) {
        return HibernateVaRegistryDaoFactory.getAggregationDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (BaseEntity obj) directly
     * @param id Identifier to delete
     */
    public void deleteBaseEntity(final String id)  {
        HibernateVaRegistryDaoFactory.getBaseEntityDao().delete(loadBaseEntity(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a BaseEntity object
     */
    public BaseEntity loadBaseEntity(final String id) {
        return HibernateVaRegistryDaoFactory.getBaseEntityDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public BaseEntity getBaseEntity(final String id) {
        return HibernateVaRegistryDaoFactory.getBaseEntityDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Collection obj) directly
     * @param id Identifier to delete
     */
    public void deleteCollection(final String id)  {
        HibernateVaRegistryDaoFactory.getCollectionDao().delete(loadCollection(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Collection object
     */
    public Collection loadCollection(final String id) {
        return HibernateVaRegistryDaoFactory.getCollectionDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
    @Transactional
     public Collection getCollection(final String id) {
        return HibernateVaRegistryDaoFactory.getCollectionDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (DataIdentifier obj) directly
     * @param id Identifier to delete
     */
    public void deleteDataIdentifier(final DataIdentifierPK id)  {
        HibernateVaRegistryDaoFactory.getDataIdentifierDao().delete(loadDataIdentifier(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a DataIdentifier object
     */
    public DataIdentifier loadDataIdentifier(final DataIdentifierPK id) {
        return HibernateVaRegistryDaoFactory.getDataIdentifierDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public DataIdentifier getDataIdentifier(final DataIdentifierPK id) {
        return HibernateVaRegistryDaoFactory.getDataIdentifierDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (DataIdentifierType obj) directly
     * @param id Identifier to delete
     */
    public void deleteDataIdentifierType(final String id)  {
        HibernateVaRegistryDaoFactory.getDataIdentifierTypeDao().delete(loadDataIdentifierType(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a DataIdentifierType object
     */
    public DataIdentifierType loadDataIdentifierType(final String id) {
        return HibernateVaRegistryDaoFactory.getDataIdentifierTypeDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public DataIdentifierType getDataIdentifierType(final String id) {
        return HibernateVaRegistryDaoFactory.getDataIdentifierTypeDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (DataLocation obj) directly
     * @param id Identifier to delete
     */
    public void deleteDataLocation(final DataLocationPK id)  {
        HibernateVaRegistryDaoFactory.getDataLocationDao().delete(loadDataLocation(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a DataLocation object
     */
    public DataLocation loadDataLocation(final DataLocationPK id) {
        return HibernateVaRegistryDaoFactory.getDataLocationDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public DataLocation getDataLocation(final DataLocationPK id) {
        return HibernateVaRegistryDaoFactory.getDataLocationDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (EntityContent obj) directly
     * @param id Identifier to delete
     */
    public void deleteEntityContent(final Integer id)  {
        HibernateVaRegistryDaoFactory.getEntityContentDao().delete(loadEntityContent(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a EntityContent object
     */
    public EntityContent loadEntityContent(final Integer id) {
        return HibernateVaRegistryDaoFactory.getEntityContentDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */

     public EntityContent getEntityContent(final Integer id) {
        return HibernateVaRegistryDaoFactory.getEntityContentDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (EntityType obj) directly
     * @param id Identifier to delete
     */
    public void deleteEntityType(final EntityTypePK id)  {
        HibernateVaRegistryDaoFactory.getEntityTypeDao().delete(loadEntityType(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a EntityType object
     */
    public EntityType loadEntityType(final EntityTypePK id) {
        return HibernateVaRegistryDaoFactory.getEntityTypeDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public EntityType getEntityType(final EntityTypePK id) {
        return HibernateVaRegistryDaoFactory.getEntityTypeDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Event obj) directly
     * @param id Identifier to delete
     */
    public void deleteEvent(final String id)  {
        HibernateVaRegistryDaoFactory.getEventDao().delete(loadEvent(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Event object
     */
    public Event loadEvent(final String id) {
        return HibernateVaRegistryDaoFactory.getEventDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Event getEvent(final String id) {
        return HibernateVaRegistryDaoFactory.getEventDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (EventType obj) directly
     * @param id Identifier to delete
     */
    public void deleteEventType(final String id)  {
        HibernateVaRegistryDaoFactory.getEventTypeDao().delete(loadEventType(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a EventType object
     */
    public EventType loadEventType(final String id) {
        return HibernateVaRegistryDaoFactory.getEventTypeDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public EventType getEventType(final String id) {
        return HibernateVaRegistryDaoFactory.getEventTypeDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (File obj) directly
     * @param id Identifier to delete
     */
    public void deleteFile(final String id)  {
        HibernateVaRegistryDaoFactory.getFileDao().delete(loadFile(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a File object
     */
    public File loadFile(final String id) {
        return HibernateVaRegistryDaoFactory.getFileDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
    @Transactional
     public File getFile(final String id) {
        return HibernateVaRegistryDaoFactory.getFileDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Fixity obj) directly
     * @param id Identifier to delete
     */
    public void deleteFixity(final FixityPK id)  {
        HibernateVaRegistryDaoFactory.getFixityDao().delete(loadFixity(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Fixity object
     */
    public Fixity loadFixity(final FixityPK id) {
        return HibernateVaRegistryDaoFactory.getFixityDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Fixity getFixity(final FixityPK id) {
        return HibernateVaRegistryDaoFactory.getFixityDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Format obj) directly
     * @param id Identifier to delete
     */
    public void deleteFormat(final Long id)  {
        HibernateVaRegistryDaoFactory.getFormatDao().delete(loadFormat(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Format object
     */
    public Format loadFormat(final Long id) {
        return HibernateVaRegistryDaoFactory.getFormatDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Format getFormat(final Long id) {
        return HibernateVaRegistryDaoFactory.getFormatDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (MetadataReference obj) directly
     * @param id Identifier to delete
     */
    public void deleteMetadataReference(final Long id)  {
        HibernateVaRegistryDaoFactory.getMetadataReferenceDao().delete(loadMetadataReference(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a MetadataReference object
     */
    public MetadataReference loadMetadataReference(final Long id) {
        return HibernateVaRegistryDaoFactory.getMetadataReferenceDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public MetadataReference getMetadataReference(final Long id) {
        return HibernateVaRegistryDaoFactory.getMetadataReferenceDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (MetadataType obj) directly
     * @param id Identifier to delete
     */
    public void deleteMetadataType(final String id)  {
        HibernateVaRegistryDaoFactory.getMetadataTypeDao().delete(loadMetadataType(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a MetadataType object
     */
    public MetadataType loadMetadataType(final String id) {
        return HibernateVaRegistryDaoFactory.getMetadataTypeDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public MetadataType getMetadataType(final String id) {
        return HibernateVaRegistryDaoFactory.getMetadataTypeDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (ProfileType obj) directly
     * @param id Identifier to delete
     */
    public void deleteProfileType(final String id)  {
        HibernateVaRegistryDaoFactory.getProfileTypeDao().delete(loadProfileType(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a ProfileType object
     */
    public ProfileType loadProfileType(final String id) {
        return HibernateVaRegistryDaoFactory.getProfileTypeDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public ProfileType getProfileType(final String id) {
        return HibernateVaRegistryDaoFactory.getProfileTypeDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Property obj) directly
     * @param id Identifier to delete
     */
    public void deleteProperty(final Long id)  {
        HibernateVaRegistryDaoFactory.getPropertyDao().delete(loadProperty(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Property object
     */
    public Property loadProperty(final Long id) {
        return HibernateVaRegistryDaoFactory.getPropertyDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Property getProperty(final Long id) {
        return HibernateVaRegistryDaoFactory.getPropertyDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Relation obj) directly
     * @param id Identifier to delete
     */
    public void deleteRelation(final RelationPK id)  {
        HibernateVaRegistryDaoFactory.getRelationDao().delete(loadRelation(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Relation object
     */
    public Relation loadRelation(final RelationPK id) {
        return HibernateVaRegistryDaoFactory.getRelationDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Relation getRelation(final RelationPK id) {
        return HibernateVaRegistryDaoFactory.getRelationDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (RelationType obj) directly
     * @param id Identifier to delete
     */
    public void deleteRelationType(final String id)  {
        HibernateVaRegistryDaoFactory.getRelationTypeDao().delete(loadRelationType(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a RelationType object
     */
    public RelationType loadRelationType(final String id) {
        return HibernateVaRegistryDaoFactory.getRelationTypeDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public RelationType getRelationType(final String id) {
        return HibernateVaRegistryDaoFactory.getRelationTypeDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Repository obj) directly
     * @param id Identifier to delete
     */
    public void deleteRepository(final String id)  {
        HibernateVaRegistryDaoFactory.getRepositoryDao().delete(loadRepository(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Repository object
     */
    public Repository loadRepository(final String id) {
        return HibernateVaRegistryDaoFactory.getRepositoryDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Repository getRepository(final String id) {
        return HibernateVaRegistryDaoFactory.getRepositoryDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (RoleType obj) directly
     * @param id Identifier to delete
     */
    public void deleteRoleType(final String id)  {
        HibernateVaRegistryDaoFactory.getRoleTypeDao().delete(loadRoleType(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a RoleType object
     */
    public RoleType loadRoleType(final String id) {
        return HibernateVaRegistryDaoFactory.getRoleTypeDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public RoleType getRoleType(final String id) {
        return HibernateVaRegistryDaoFactory.getRoleTypeDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (State obj) directly
     * @param id Identifier to delete
     */
    public void deleteState(final String id)  {
        HibernateVaRegistryDaoFactory.getStateDao().delete(loadState(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a State object
     */
    public State loadState(final String id) {
        return HibernateVaRegistryDaoFactory.getStateDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public State getState(final String id) {
        return HibernateVaRegistryDaoFactory.getStateDao().get(id);
    }  

    /** Deletes an object of a given Id. 
     * Will load the object internally so consider using delete (Transition obj) directly
     * @param id Identifier to delete
     */
    public void deleteTransition(final TransitionPK id)  {
        HibernateVaRegistryDaoFactory.getTransitionDao().delete(loadTransition(id));
    }
	
    /**
     * Loads the given Object.
     * @param id Identifier to load
     * @return a Transition object
     */
    public Transition loadTransition(final TransitionPK id) {
        return HibernateVaRegistryDaoFactory.getTransitionDao().load(id);
    }
    /**
     * Loads the given Object.
     * @param id Id to load
     * @return An object of type T
     */
     public Transition getTransition(final TransitionPK id) {
        return HibernateVaRegistryDaoFactory.getTransitionDao().get(id);
    }  
    /** Returns a singleton instance of this class.
     * @return an singleton instance
     */
    public static synchronized DataLayerVaRegistry getInstance() {


        if (instance == null) {
        	if (context == null) {
               context = new ClassPathXmlApplicationContext(new String[] {
                        "applicationContext.xml"}) ;
        	}
     		instance = (DataLayerVaRegistry) context.getBean("dataLayerVaRegistryImpl");
        }
        
        return instance; 
    }
    /** Returns a query handle.
     * @param query Query to use
     * @return A query instance
     */
    @Basic(fetch = FetchType.EAGER)
     public Query createQuery(final String query) {
        return this.sessionFactory.getCurrentSession().createQuery(query);
    }
    /** Returns a criteria handle.
     * @param criteria Criteria to use
     * @return A criteria instance
     */
     public Criteria createCriteria(final String criteria) {
        return this.sessionFactory.getCurrentSession().createCriteria(criteria);
    }
    /** Returns a Query handle based on your package-level named query.
     * @param query Query to use
     * @return A query instance
     */
     public Query getNamedQuery(final String query) {
        return this.sessionFactory.getCurrentSession().getNamedQuery(query);
    }
    /** Create a new Criteria instance, for the given entity class, or a superclass of an entity class.
	* @param persistentObject a class, which is persistent, or has persistent subclasses 
	* @return Criteria instance
	*/
	@SuppressWarnings("unchecked")
	public Criteria createCriteria(Class persistentObject) {
        return this.sessionFactory.getCurrentSession().createCriteria(persistentObject);
    }
    /** Flushes the currently open session.
	*/
    @Transactional
	public void flushSession() {
        this.sessionFactory.getCurrentSession().flush();
    }


    @Transactional
    public void closeSession() {
        this.sessionFactory.getCurrentSession().close();
    }
    /** Clears the currently open session.
	*/
	public void clearSession() {
        this.sessionFactory.getCurrentSession().clear();
    }
    /** Flushes and clears the currently open session.
	*/
	public void flushAndClearSession() {
		flushSession();
		clearSession();
    }
	/** Call currentSession.replicate.
	 * @param obj to replicate
	 * @param replicationMode mode
	 */ 
	public void replicate(Object obj, ReplicationMode replicationMode) {
		this.sessionFactory.getCurrentSession().replicate(obj, replicationMode);
	}

	/** Hibernate Merge. 
	 * @param obj to merge
	 * @return obj merged.
	 */
	public Object merge(Object obj) {
		return this.sessionFactory.getCurrentSession().merge(obj);
	}
	/** Returns the current session.
	 * @return the currently active session
	 */
	public Session getCurrentSession() {
		return this.sessionFactory.getCurrentSession();
	}

    @Override
    public Session createNewSession() {
        org.hibernate.classic.Session session = this.sessionFactory.openSession();
        ManagedSessionContext.bind(session);
        session.beginTransaction();
        return session;
    }

    /** Returns a query handle.
     * @param query Query to use
     * @return A query instance
     */
     public SQLQuery createSQLQuery(final String query) {
        return this.sessionFactory.getCurrentSession().createSQLQuery(query);
    }
    /** Remove this instance from the session cache. 
	 * Changes to the instance will not be synchronized with the database
	 * @param obj object to evict
	 */
	public void evict(Object obj) {
        this.sessionFactory.getCurrentSession().evict(obj);
    }
    /**
     * Return the persistent instance of the given entity class with the given 
     * identifier, or null if there is no such persistent instance. 
     * (If the instance, or a proxy for the instance, is already 
     * associated with the session, return that instance or proxy)
     *
     * @param clazz a persistent class
     * @param id a valid identifier of an existing persistent instance of the class
     * @return a persistent instance or null
     * @throws org.hibernate.HibernateException
     */
	public Object get(Class<?> clazz, Serializable id) throws HibernateException {
        return this.sessionFactory.getCurrentSession().get(clazz, id);
    }	


    /**
     * Return the persistent instance of the given entity class with the given identifier, assuming that the instance exists.
     *You should not use this method to determine if an instance exists (use get() instead). Use this only to retrieve an instance that you assume exists, where non-existence would be an actual error.
     *
     * @param clazz a persistent class
     * @param id a valid identifier of an existing persistent instance of the class
     * @return the persistent instance or proxy
     * @throws org.hibernate.HibernateException
     */
	public Object load(Class<?> clazz, Serializable id) throws HibernateException {
        return this.sessionFactory.getCurrentSession().load(clazz, id);  
    }
	/**
	 * Reattaches the given entity to the current session using LockMode.NONE
	 *
	 * @param entity to reattach
	 */
	public void reattachEntityWithNoLock(IPojoGenEntity entity) {
		if (entity != null) {
        		this.sessionFactory.getCurrentSession().lock(entity, LockMode.NONE);
    		}
	}
	/**
	 * Reattaches the given entities to the current session.
	 *
	 * @param entities to attach
	 */
	public void reattachEntitiesWithNoLock(java.util.Collection<? extends IPojoGenEntity> entities) {
   		if (entities != null) {
		       for (IPojoGenEntity entity : entities) {
            		this.sessionFactory.getCurrentSession().lock(entity, LockMode.NONE);
        		 }
    		}
	}}

