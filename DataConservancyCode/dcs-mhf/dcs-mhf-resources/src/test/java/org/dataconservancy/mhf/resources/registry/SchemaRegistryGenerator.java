package org.dataconservancy.mhf.resources.registry;

import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.io.FileUtils;
import org.dataconservancy.mhf.instance.api.MetadataFormatId;
import org.dataconservancy.model.builder.DcsModelBuilder;
import org.dataconservancy.model.builder.xstream.DcsXstreamStaxModelBuilder;
import org.dataconservancy.model.dcp.Dcp;
import org.dataconservancy.registry.api.support.BasicRegistryEntryImpl;
import org.dataconservancy.registry.api.support.BasicRegistryEntryMapper;
import org.dataconservancy.registry.impl.metadata.shared.DcsMetadataFormat;
import org.dataconservancy.registry.impl.metadata.shared.DcsMetadataScheme;
import org.dataconservancy.registry.impl.metadata.shared.MetadataFormatMapper;
import org.dataconservancy.registry.impl.metadata.shared.MetadataSchemeMapper;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static org.junit.Assert.assertEquals;

/**
 * A utility for serializing registry entries of DcsMetadataFormat objects on the filesystem.  Specifically this
 * tool has been used to generate the resources in org/dataconservancy/mhf/resources/registry/metadataformat.
 */
class SchemaRegistryGenerator {

    /**
     * Serializes DCP objects to DCP XML and back.
     */
    private DcsModelBuilder modelBuilder = new DcsXstreamStaxModelBuilder();

    /**
     * Serializes MetadataScheme objects to DCP XML and back.
     */
    private MetadataSchemeMapper schemeMapper;

    /**
     * Serializes MetadataFormat objects (including member MetadataScheme objects) to registry entries as DCP XML.
     */
    private MetadataFormatMapper formatMapper;

    /**
     * The directory on the filesystem where serializations generated by this utility are persisted
     */
    private File baseDirectory;

    public static void main(String[] args) {
        Options opts = new Options();
        Option outDirOpt = new Option("o", true, "Output directory");
        Option verboseOpt = new Option("v", false, "Verbose output");
        Option portableOpt = new Option("p", false, "Portable registry (uses class paths when referencing resources, " +
                "instead of absolute file names.");
        opts.addOption(outDirOpt);
        opts.addOption(verboseOpt);
        opts.addOption(portableOpt);

        CommandLine cmdLine = null;
        try {
            final CommandLineParser parser = new BasicParser();
            cmdLine = parser.parse(opts, args);
        } catch (ParseException e) {
            System.err.print("Error parsing command line: " + e.getMessage());
            System.exit(1);
        }

        SchemaRegistryGenerator generator = new SchemaRegistryGenerator();

        File outDir = new File(cmdLine.getOptionValue(outDirOpt.getOpt(), System.getProperty("user.dir")));
        if (!outDir.isAbsolute()) {
            // Then the out dir is relative.  Make it absolute relative to the current working directory.
            outDir = new File(new File(System.getProperty("user.dir")), outDir.getPath());
        }

        // If the directory doesn't exist, attempt to create it
        if (!outDir.exists()) {
            try {
                FileUtils.forceMkdir(outDir);
            } catch (IOException e) {
                System.err.println("Unable to create output directory " + outDir + ": " + e.getMessage());
                System.exit(1);
            }
        }

        // Sanity checks
        if (!outDir.exists()) {
            System.err.println(outDir + " cannot be created, does not exist, or you don't have permissions to read " +
                    "it.");
            System.exit(1);
        }

        if (!outDir.canWrite()) {
            System.err.println("Your user does not have sufficient privileges to write to " + outDir);
            System.exit(1);
        }

        if (!outDir.isDirectory()) {
            System.err.println(outDir + " is not a directory.  Maybe it is file?");
            System.exit(1);
        }

        if (isVerbose(verboseOpt, cmdLine)) {
            System.err.println("Writing registry under directory " + outDir);
        }

        if (isVerbose(verboseOpt, cmdLine)) {
            System.err.println("Using " +
                    (isVerbose(portableOpt, cmdLine) ? "class paths " : "absolute file paths ") +
                    "when referencing registry resources.");
        }

        // If we are doing portable output, tack on the classpath to the end of the outdir, unless it is there already.
        if (!outDir.getAbsolutePath().endsWith(SchemaRegistryGeneratorConstants.METADATA_REGISTRY_BASE_RESOURCE_PATH)) {
            outDir = new File(outDir, SchemaRegistryGeneratorConstants.METADATA_REGISTRY_BASE_RESOURCE_PATH);
            try {
                FileUtils.forceMkdir(outDir);
            } catch (IOException e) {
                System.err.println("Internal error creating directory " + outDir);
                e.printStackTrace(System.err);
                System.exit(1);
            }

            if (isVerbose(verboseOpt, cmdLine)) {
                System.err.println("Base class path for referencing resources is " +
                        SchemaRegistryGeneratorConstants.METADATA_REGISTRY_BASE_RESOURCE_PATH);
            }
        }

        generator.baseDirectory = outDir;
        generator.schemeMapper = new MetadataSchemeMapper();
        generator.schemeMapper.setBaseDirectory(outDir);
        generator.formatMapper = new MetadataFormatMapper(generator.schemeMapper);
        generator.formatMapper.setBaseDirectory(outDir);

        try {
            generator.testGenerateSchemaRegistry((isVerbose(portableOpt, cmdLine)), outDir);
        } catch (Exception e) {
            System.err.println("Error writing registry to " + outDir + ": " + e.getMessage());
            if (isVerbose(verboseOpt, cmdLine)) {
                e.printStackTrace(System.err);
            }
            System.exit(1);
        }

        if (isVerbose(verboseOpt, cmdLine)) {
            System.err.println("Wrote registry entries to " + outDir);
        }

        System.exit(0);
    }

    private static boolean isVerbose(Option verboseOpt, CommandLine cmdLine) {
        return cmdLine.hasOption(verboseOpt.getOpt());
    }

    public void testGenerateSchemaRegistry(boolean transform, File baseDirectory) throws Exception {
        final Dcp fgdcRegistryEntryDcp = generateFgdcSchemaRegistryEntryDcp(transform);

        Set<String> entryIds = formatMapper.discover(fgdcRegistryEntryDcp);
        assertEquals(1, entryIds.size());

        FileOutputStream out = new FileOutputStream(new File(baseDirectory, SchemaRegistryGeneratorConstants.FGDC_DCP_REGISTRY_ENTRY));
        modelBuilder.buildSip(fgdcRegistryEntryDcp, out);
        out.close();

        final Dcp xsdRegistryEntryDcp = generateXsdSchemaRegistryEntryDcp(transform);
        entryIds = formatMapper.discover(xsdRegistryEntryDcp);
        assertEquals(1, entryIds.size());

        out = new FileOutputStream(new File(baseDirectory, SchemaRegistryGeneratorConstants.XSD_DCP_REGISTRY_ENTRY));
        modelBuilder.buildSip(xsdRegistryEntryDcp, out);
        out.close();
    }


    private DcsMetadataScheme generateFgdcMaster() {
        DcsMetadataScheme scheme = new DcsMetadataScheme();
        scheme.setName(SchemaRegistryGeneratorConstants.FGDC_FORMAT_NAME);
        scheme.setSchemaUrl(SchemaRegistryGeneratorConstants.FGDC_MASTER_URL);
        scheme.setSchemaVersion(SchemaRegistryGeneratorConstants.FGDC_VERSION);
        scheme.setSource("classpath:" + SchemaRegistryGeneratorConstants.FGDC_MASTER_RESOURCE);
        return scheme;
    }

    private DcsMetadataScheme generateFgdcSection(int sectionId) {
        DcsMetadataScheme scheme = new DcsMetadataScheme();
        scheme.setName(SchemaRegistryGeneratorConstants.FGDC_FORMAT_NAME + ", section " + sectionId);
        scheme.setSchemaUrl(String.format(SchemaRegistryGeneratorConstants.FGDC_SECT_URL_FORMAT, sectionId));
        scheme.setSchemaVersion(SchemaRegistryGeneratorConstants.FGDC_VERSION);
        scheme.setSource("classpath:" + String.format(SchemaRegistryGeneratorConstants.FGDC_SECT_RESOURCE_FORMAT, sectionId));
        return scheme;
    }

    private DcsMetadataScheme generateFgdcDtd() {
        DcsMetadataScheme scheme = new DcsMetadataScheme();
        scheme.setName(SchemaRegistryGeneratorConstants.FGDC_FORMAT_NAME + " DTD");
        scheme.setSchemaUrl(SchemaRegistryGeneratorConstants.FGDC_DTD_URL);
        scheme.setSchemaVersion(SchemaRegistryGeneratorConstants.FGDC_VERSION);
        scheme.setSource("classpath:" + SchemaRegistryGeneratorConstants.FGDC_BASE_RESOURCE_PATH +
                SchemaRegistryGeneratorConstants.FGDC_DTD);
        return scheme;
    }

    private DcsMetadataFormat generateFgdcMetadataFormat() {
        DcsMetadataFormat format = new DcsMetadataFormat();
        format.setName(SchemaRegistryGeneratorConstants.FGDC_FORMAT_NAME);
        format.setVersion(SchemaRegistryGeneratorConstants.FGDC_VERSION);
        format.addScheme(generateFgdcMaster());
        format.setId(SchemaRegistryGeneratorConstants.FGDC_XML_FORMAT_ID);
        for (DcsMetadataScheme scheme : generateAllFgdcMetadataSchemes()) {
            format.addScheme(scheme);
        }

        return format;
    }

    private DcsMetadataFormat generateXsdMetadataFormat() {
        DcsMetadataFormat format = new DcsMetadataFormat();
        format.setName("XSD Schema");
        format.setVersion("http://www.w3.org/2001/XMLSchema");
        format.setId(SchemaRegistryGeneratorConstants.XSD_FORMAT_ID);
        for (DcsMetadataScheme s : generateAllXsdMetadataSchemes()) {
            format.addScheme(s);
        }

        return format;
    }

    private List<DcsMetadataScheme> generateAllXsdMetadataSchemes() {
        DcsMetadataScheme master = new DcsMetadataScheme();
        master.setName("XSD Schema");
        master.setSchemaUrl("http://www.w3.org/2001/XMLSchema.xsd");
        master.setSchemaVersion("http://www.w3.org/2001/XMLSchema");
        master.setSource("classpath:" + String.format(SchemaRegistryGeneratorConstants.XSD_SECT_RESOURCE_FORMAT, "XMLSchema.xsd"));

        DcsMetadataScheme xmlSchemaDtd = new DcsMetadataScheme();
        xmlSchemaDtd.setName("XSD Schema: XML DTD");
        xmlSchemaDtd.setSchemaUrl("http://www.w3.org/2001/XMLSchema.dtd");
        xmlSchemaDtd.setSchemaVersion("http://www.w3.org/2001/XMLSchema");
        xmlSchemaDtd.setSource("classpath:" + String.format(SchemaRegistryGeneratorConstants.XSD_SECT_RESOURCE_FORMAT, "XMLSchema.dtd"));

        DcsMetadataScheme xmlXsd = new DcsMetadataScheme();
        xmlXsd.setName("XSD Schema: XML XSD");
        xmlXsd.setSchemaUrl("http://www.w3.org/2001/xml.xsd");
        xmlXsd.setSchemaVersion("http://www.w3.org/2001/XMLSchema");
        xmlXsd.setSource("classpath:" + String.format(SchemaRegistryGeneratorConstants.XSD_SECT_RESOURCE_FORMAT, "xml.xsd"));

        DcsMetadataScheme datatypesDtd = new DcsMetadataScheme();
        datatypesDtd.setName("XSD Schema: Datatypes DTD");
        datatypesDtd.setSchemaUrl("http://www.w3.org/2001/datatypes.dtd");
        datatypesDtd.setSchemaVersion("http://www.w3.org/2001/XMLSchema");
        datatypesDtd.setSource("classpath:" + String.format(SchemaRegistryGeneratorConstants.XSD_SECT_RESOURCE_FORMAT, "datatypes.dtd"));

        List<DcsMetadataScheme> schemes = new ArrayList<DcsMetadataScheme>();
        schemes.add(master);
        schemes.add(xmlSchemaDtd);
        schemes.add(xmlXsd);
        schemes.add(datatypesDtd);

        return schemes;
    }

    private Dcp generateFgdcSchemaRegistryEntryDcp(boolean transform) throws IOException {
        final DcsMetadataFormat format = generateFgdcMetadataFormat();

        final Set<String> keys = new HashSet<String>();
        final String entryId = SchemaRegistryGeneratorConstants.METADATA_REGISTRY_ID + "entry:id:1";
        keys.add(entryId);
        keys.add(MetadataFormatId.FGDC_XML_FORMAT_ID);

        final BasicRegistryEntryImpl<DcsMetadataFormat> formatRegistryEntry =
                new BasicRegistryEntryImpl<DcsMetadataFormat>(entryId, format, BasicRegistryEntryMapper.REGISTRY_ENTRY_DU_TYPE, keys,
                        SchemaRegistryGeneratorConstants.FGDC_1998_SCHEMA_DESCRIPTION
                );

        if (transform) {
            return FileSrcTransformer.transform(formatMapper.to(formatRegistryEntry, null),
                    SchemaRegistryGeneratorConstants.BASE_RESOURCE_PATH);
        } else {
            return formatMapper.to(formatRegistryEntry, null);
        }
    }

    private Dcp generateXsdSchemaRegistryEntryDcp(boolean transform) throws IOException {
        final DcsMetadataFormat format = generateXsdMetadataFormat();

        final Set<String> keys = new HashSet<String>();
        final String entryId = SchemaRegistryGeneratorConstants.METADATA_REGISTRY_ID + "entry:id:2";
        keys.add(entryId);
        keys.add(SchemaRegistryGeneratorConstants.XSD_FORMAT_ID);

        final BasicRegistryEntryImpl<DcsMetadataFormat> formatRegistryEntry =
                new BasicRegistryEntryImpl<DcsMetadataFormat>(entryId, format, BasicRegistryEntryMapper.REGISTRY_ENTRY_DU_TYPE, keys,
                        SchemaRegistryGeneratorConstants.XSD_SCHEMA_DESCRIPTION
                );

        if (transform) {
            return FileSrcTransformer.transform(formatMapper.to(formatRegistryEntry, null),
                    SchemaRegistryGeneratorConstants.BASE_RESOURCE_PATH);
        } else {
            return formatMapper.to(formatRegistryEntry, null);
        }
    }

    /**
     * Generates all of the DcsMetadataScheme objects that comprise the FGDC DcsMetadataFormat.
     * <p/>
     * Returns a List containing DcsMetadataSchemes for the following:
     * <br/>
     * <dl>
     *     <dt>fgdc-std-001-1998.xsd</dt>
     *     <dd>Master FGDC 1998 XSD schema document (includes the following sections). <em>Must</em> be the
     *         head of the returned {@code List}</dd>
     *     <dt>fgdc-std-001-1998-sect<em>xx</em>.xsd</dt>
     *     <dd>XSD schema documents included by the master FGDC XSD schema document (there are a total of 10
     *         sections)</dd>
     *     <dt>fgdc-std-001-1998.dtd</dt>
     *     <dd>FGDC 1998 DTD document</dd>
     * </dl>
     *
     * @return a {@code List} headed by the {@code DcsMetadataScheme} that represents the master FGDC 1998 XSD schema
     *         document.
     */
    private List<DcsMetadataScheme> generateAllFgdcMetadataSchemes() {
        List<DcsMetadataScheme> schemes = new ArrayList<DcsMetadataScheme>();

        // The main FGDC 1998 schema document
        //   fgdc-std-001-1998.xsd
        // N.B. this should always be first in the list, since it is the
        // main schema document that includes the remaining sections.

        schemes.add(generateFgdcMaster());

        // There are 10 included XSD files comprising the entirety of the FGDC 1998 schema.
        //   fgdc-std-001-1998-sect01.xsd
        //   fgdc-std-001-1998-sect02.xsd
        //   ...
        //   fgdc-std-001-1998-sect10.xsd

        for (int i = 1; i < 11; i++) {
            schemes.add(generateFgdcSection(i));
        }

        // There is one FGDC 1998 DTD document
        //   fgdc-std-001-1998.dtd
        // N.B. its position in the List of returned schemes is not important.

        schemes.add(generateFgdcDtd());

        return schemes;
    }
}
