/*
 * Copyright 2012 Johns Hopkins University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.dataconservancy.ui.services;

import org.dataconservancy.dcs.id.api.IdService;
import org.dataconservancy.dcs.ingest.EventManager;
import org.dataconservancy.model.builder.DcsModelBuilder;
import org.dataconservancy.model.builder.xstream.DcsXstreamStaxModelBuilder;
import org.dataconservancy.registry.api.RegistryEntry;
import org.dataconservancy.registry.impl.metadata.shared.DcsMetadataFormat;
import org.dataconservancy.ui.dao.ArchiveDepositInfoDAO;
import org.dataconservancy.ui.dcpmap.DcpMapper;
import org.dataconservancy.ui.exceptions.ArchiveServiceException;
import org.dataconservancy.ui.model.ArchiveDepositInfo;
import org.dataconservancy.ui.model.ArchiveDepositInfo.Status;
import org.dataconservancy.ui.model.Collection;
import org.dataconservancy.ui.model.DataFile;
import org.dataconservancy.ui.model.DataItem;
import org.dataconservancy.ui.model.MetadataFile;
import org.dataconservancy.ui.profile.Profile;
import org.dataconservancy.ui.util.ArchiveSearchResult;

import java.util.List;

/**
 * Archive service implementation that stores information in memory and data in
 * temporary files. It actually uses ArchiveServiceImpl internally. Deposits are
 * synchronous. Deposit status is only updated when pollArchive is called.
 */
public class InMemoryArchiveServiceImpl implements ArchiveService {
    private MockArchiveDepositInfoDAO deposit_info_dao;
    private final ArchiveService archive_service;
    private final DcsModelBuilder model_builder = new DcsXstreamStaxModelBuilder();

    /**
     * Creates a new instance configured not to "fail" ingests.
     *
     * @param ds_mapper the DataItem mapper - used to map Dcp packages to and from DataItem UI objects
     * @param col_mapper the Collection mapper - used to map Dcp packages to and from Collection UI objects
     * @param resolver the deposit document resolver - used to resolve the status of a deposit with the archive
     * @param mockArchiveUtil the mock archive utility - used to store deposited DCS entities
     */
    public InMemoryArchiveServiceImpl(DcpMapper<DataItem> ds_mapper,
                                      Profile<DataItem> dataItemProfile,
                                      DcpMapper<Collection> col_mapper,
                                      DcpMapper<MetadataFile> mf_mapper,
                                      DcpMapper<DataFile> df_mapper,
                                      org.dataconservancy.profile.api.DcpMapper<RegistryEntry<DcsMetadataFormat>> re_mapper,
                                      DepositDocumentResolver resolver,
                                      MockArchiveUtil mockArchiveUtil,
                                      IdService idService, MockArchiveDepositInfoDAO archiveDepositInfoDAO) {
        this(ds_mapper, dataItemProfile, col_mapper, mf_mapper, df_mapper, re_mapper, resolver, mockArchiveUtil, idService, false, archiveDepositInfoDAO);
    }

    /**
     * Creates a new instance which can be configured to "fail" ingests.
     * <p/>
     * Failing ingests is a half-hearted attempt, because the deposit and ingest logic is executed without consulting
     * the {@code failDeposits} flag.  However, when the flag is {@code true}, the events generated by the ingest will
     * <em>always</em> be {@code ingest.failed} events; these events will be exposed via the deposit Atom feed and
     * the {@code DepositDocument}.
     *
     * @param ds_mapper the DataItem mapper - used to map Dcp packages to and from DataItem UI objects
     * @param col_mapper the Collection mapper - used to map Dcp packages to and from Collection UI objects
     * @param resolver the deposit document resolver - used to resolve the status of a deposit with the archive
     * @param mockArchiveUtil the mock archive utility - used to store deposited DCS entities
     * @param failDeposits - flag indicating whether or not a deposit should be immediately failed
     */
    public InMemoryArchiveServiceImpl(DcpMapper<DataItem> ds_mapper,
                                      Profile<DataItem> dataItemProfile,
                                      DcpMapper<Collection> col_mapper,
                                      DcpMapper<MetadataFile> mf_mapper,
                                      DcpMapper<DataFile> df_mapper,
                                      org.dataconservancy.profile.api.DcpMapper<RegistryEntry<DcsMetadataFormat>> re_mapper,
                                      DepositDocumentResolver resolver,
                                      MockArchiveUtil mockArchiveUtil,
                                      IdService idService,
                                      boolean failDeposits,
                                      MockArchiveDepositInfoDAO archiveDepositInfoDAO) {
        if (ds_mapper == null || col_mapper == null) {
            throw new IllegalArgumentException("DataItem and Collection mappers must not be null.");
        }

        if (dataItemProfile == null) {
            throw new IllegalArgumentException("Data Item Profile must not be null.");
        }

        final EventManager em;
        if (failDeposits) {
            em = new AlwaysFailingEventManager();
        } else {
            em = new InMemoryEventManager();
        }

        this.deposit_info_dao = archiveDepositInfoDAO;
        final MockDcsConnector connector = new MockDcsConnector(em, mockArchiveUtil, model_builder);
        connector.setDeleteFilesOnExit(false);
        this.archive_service = new ArchiveServiceImpl(archiveDepositInfoDAO,
                ds_mapper, df_mapper, col_mapper, mf_mapper, re_mapper,
                connector, dataItemProfile, resolver, idService, mockArchiveUtil, 0);
        ((ArchiveServiceImpl)archive_service).setAncestrySearcher(new ArchiveAncestrySearcherImpl(connector));
        ((ArchiveServiceImpl)archive_service).setParentSearcher(new ArchiveParentSearcherImpl(connector));

    }

    /**
     * Resets the in-memory state of this instance, allowing it to be re-used.  Often called in
     * a {@code @After} or {@code @Before} test method.
     */
    public void reset() {
        deposit_info_dao.reset();
    }

    public void pollArchive() throws ArchiveServiceException {
        archive_service.pollArchive();
    }

    public String deposit(Collection col) throws ArchiveServiceException {
        return archive_service.deposit(col);
    }

    public String deposit(String deposit_id, DataItem ds)
            throws ArchiveServiceException {
        return archive_service.deposit(deposit_id, ds);
    }
    
    public String deposit(String deposit_id, MetadataFile mf)
            throws ArchiveServiceException {
        return archive_service.deposit(deposit_id, mf);
    }
    
    public String deposit(RegistryEntry<DcsMetadataFormat> re) 
            throws ArchiveServiceException {
        return archive_service.deposit(re);
    }

    public Status getDepositStatus(String deposit_id) {
        return archive_service.getDepositStatus(deposit_id);
    }

    public List<String> listCollections(Status status) {
        return archive_service.listCollections(status);
    }

    public ArchiveSearchResult<Collection> retrieveCollection(String deposit_id)
            throws ArchiveServiceException {
        return archive_service.retrieveCollection(deposit_id);
    }

    public List<String> listDataSets(Status status) {
        return archive_service.listDataSets(status);
    }

    public ArchiveSearchResult<DataItem> retrieveDataSet(String deposit_id)
            throws ArchiveServiceException {
        return archive_service.retrieveDataSet(deposit_id);
    }
    
    public List<String> listMetadataFiles(Status status) {
        return archive_service.listMetadataFiles(status);
    }
    
    public ArchiveSearchResult<MetadataFile> retrieveMetadataFile(String deposit_id)
            throws ArchiveServiceException {
        return archive_service.retrieveMetadataFile(deposit_id);
    }

    public List<ArchiveDepositInfo> listDepositInfo(String object_id,
                                                    Status status) {
        return archive_service.listDepositInfo(object_id, status);
    }

    public ArchiveSearchResult<DataItem> retrieveDataSetsForCollection(String collection_id,
                                                                      int numberOfResults,
                                                                      int offset)
            throws ArchiveServiceException {
        return archive_service.retrieveDataSetsForCollection(collection_id, numberOfResults, offset);
    }
    
    public void setDepositInfoDAO(MockArchiveDepositInfoDAO archiveDepositInfoDAO) {
        this.deposit_info_dao = archiveDepositInfoDAO;
    }
}
